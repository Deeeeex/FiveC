# 服务器端设计文档

## 系统概述

为了实现广域网五子棋连接对战，即在不同局域网下的机器互相连接，且在不考虑内网穿透等实现手段的情况下，我们需要一个服务器端，用于对战双方数据的转发，服务器端程序部署于云服务器，用于示例的服务器IP地址为``101.34.252.176``，服务提供商为[腾讯云](https://cloud.tencent.com/)。

## 运行环境

用于示例的云服务器系统环境为``CentOS 7.6 64bit``

## 功能设计

在服务器端程序开启的情况下，会监听三个端口，``CONF_PORT``，``HOST_PORT``，``GUEST_PORT``。其中，``CONF_PORT``用于接收客户端程序的申请，另外两个端口用于建立连接，实现信息的转发。具体过程如下：

1. 客户端向服务器端发出申请，连接到``CONF_PORT``。
2. 服务器端向``CONF_PORT``发送出当前的游戏状态``Game_Status``，分为``VACANT``，``WAITING``，``ONGOING``，分别表示空闲，已有玩家等待中，以及游戏进行中。
   * 若当前为空闲，则当前申请的客户端将与``HOST_PORT``建立连接，等待另一位玩家进入游戏，并将游戏状态``Game_Status``修改为``WAITING``。
   * 若当前为等待，则当前申请的客户端将与``GUEST_PORT``建立连接，开始游戏，并将并将游戏状态``Game_Status``修改为``ONGOING``。
   * 若当前为游戏中，则断开连接，并返回信息。

3. 当双方玩家都分别建立连接后，开始进行对战，服务器同时监听双方的信息，并不作修改地转发。
4. 当一局游戏结束之后，玩家断开连接，将游戏状态``Game_Status``修改为``VACANT``，并且还原为最初监听状态。

## 关键算法设计

### 多进程

为了实现对三个端口的同时监听，以及互不干扰的并行运行，选择使用``MultiProcess``实现这项功能。当服务器处于正常监听状态时，进程树如下：

```c
Server(4257)─┬─Server(15329)//Listening to CONF_PORT
             ├─Server(15330)//Listening to HOST_PORT
             └─Server(15331)//Listening to GUEST_PORT
```

如图，主进程``Server（4257）``有三个子进程，分别实现对于三个端口的监听。

当``CONF_PORT``收到来自客户端的申请时，会从``Game_Status``文件获取当前的游戏状态，并将其发送给发出申请的客户端。

当游戏成功建立的时候，监听``HOST_PORT``和``GUEST_PORT``的两个进程将分别``fork()``一个子进程，用于向对应端口发送信息，实现发送和监听的分离。

### 进程间通信

由于程序涉及到多个进程，而不同进程之间的变量是不共享的，且不同进程之间有通信的需求，因此需要使用一些方法，实现进程之间的通信。这里主要用了三种方法：共享文件，管道通信，以及信号机制。

#### 共享文件

关于游戏状态``Game_Status``的存储和读取，选择使用文件，在目录下建立一个``Game_Status``文件，用于存储当前的游戏状态。服务器程序每次运行的时候，都会将其初始化为``WAITING``，以供后续进程读取和修改。

读取过程如代码所示：

```c
Game_Status_fd = open("Game_Status", O_RDONLY);
read(Game_Status_fd, &Game_Status, sizeof(int));
close(Game_Status_fd);
```

其中``Game_Status_fd``和``Game_Status``均为``int``型变量，``Game_Status_fd``用作文件描述符，``Game_Status``用于读取文件中存储的单个``int``型数据，表示不同状态，如下：

```c
#define VACANT 0
#define WAITING 1
#define ONGOING 2
```

